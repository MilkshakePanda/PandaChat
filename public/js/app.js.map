{"version":3,"sources":["node_modules/browser-pack/_prelude.js","assets/js/app.js","assets/js/lib/socket.js","assets/js/lib/sounds.js"],"names":[],"mappings":"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","file":"app.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import {Socket} from './lib/socket'\n\nconst messageInput  = document.querySelector(\".chat__message-input\")\nconst usernameInput = document.querySelector(\".login__username\")\n\n\nSocket.connection = new WebSocket('wss://socketchat123.herokuapp.com')\n\n// When the window loads\nwindow.onload = () => usernameInput.focus() \n\n\n// On open\nSocket.connection.onopen = () => console.log(\"connected\") \n\n// On error\nSocket.connection.onerror = (error) => console.log(\"There was an error of type \" + error + \" please try again shortly\")\n\n// On Message\nSocket.connection.onmessage = (event) => {\n\n    const incomingData = JSON.parse(event.data)\n    const eventAction  = incomingData.action\n\n    // Here we check the action event sent by the server\n    // depending on the action, we perform different tasks\n    // Ex: if chat message then display message but if new user then notifyChatRoom and updateConnectedUsers\n    switch(eventAction) {\n\n        case \"new message\":\n            Socket.displayMessage(incomingData)\n            break;\n        case \"user joined\":\n            Socket.notifyUsers(incomingData)\n            Socket.updateConnectedUsers(incomingData.usernames)\n            break;\n        case \"user left\":\n            Socket.notifyUsers(incomingData)\n            Socket.updateConnectedUsers(incomingData.usernames)\n            break;\n    }\n\n}\n\n// We listen for keydown events\n// When the user hits enter\n// If when they hit enter, the value of username is defined, then that means the user is trying to send a message (because they can see the chat page)\n    // So in that case we call the sendMessage function\n// However is username is not defined then they are still looking at the login page which means they want to set their username\n    // in that case we call the setUsername() function\n\nwindow.onkeydown = (event) => {\n\n    if (event.which === 13) {\n        event.preventDefault()\n\n        if (Socket.username && messageInput.value) {\n            Socket.sendMessage()\n        }\n        else {\n            Socket.setUsername()\n        }\n\n    }\n}\n\n","import {Sounds} from './sounds'\n\nlet Socket = {\n    username: null,\n    connection: null, \n}\n\nconst loginPage     = document.querySelector(\".login\")\nconst chatPage     = document.querySelector(\".chat\")\nconst usernameInput = document.querySelector(\".login__username\")\nconst messageInput  = document.querySelector(\".chat__message-input\")\nconst usernamesContainer = document.querySelector(\".chat__users-list\")\nconst messageBox    = document.querySelector(\".chat__messages\")\n\n// Send Message\n// **This function is fired whenever the user hits enter and a username is set**\n// 1. We create a new JSON object with an event action of new message (which will be caught by the server to send back the content)\n// 2. We send it to the server\n// 3. We clear the input\n\n// **Note that on the server we are not explicitly checking for a \"new message\" event. We are listening for a \"new user\" event. If the event isn't that one then it's obviously a \"new message\" event (I'm currently fasting at the time of writing, this might not make sense at all brah)\n\nSocket.sendMessage = () => {\n    const message = JSON.stringify({\n        action: \"new message\",\n        body: messageInput.value\n\n    })\n    Socket.connection.send(message)\n    messageInput.value = \"\"\n}\n\n// Display Message\n// This function is called when the event sent by the server is \"new message\"\n// It takes the data sent by the server as a parameter\n// 1. we create a template string containing two span tags wrapped around a <p> tag\n// 2. we add the values from the data object to the elements\n// 3. we set the innerHTML of the chat container to that string\n\nSocket.displayMessage = (data) => {\n\n    let messageToDisplay  = `\n    \n    <div class=\"message\">\n        <span class=\"message__avatar\" style=\"background-color: ${data.color}\">${data.initials}</span>\n        <p class=\"message__body\">\n            <strong class=\"message__username\">${data.user}</strong>\n            ${data.body}\n        </p>\n        <time>${data.time}</time>\n    </div>\n    `\n\n    messageBox.innerHTML += messageToDisplay\n    Sounds.playNotification()\n}\n\n\n// Notify Users\n// 1. We set the innerHTML of the notificationContainer to the message sent by the server (\"user connected, \"user left the chat\")\n// 2. We set the background color of the container to the one specified in the data object sent by the server\n// 3. We show it (it's display none by default\")\n// 4. After two seconds we hide it again\n\n// Create the element on the fly using template strings (className: chat__notifications)\nSocket.notifyUsers = (data) => {\n\n    const notificationMessage = `<div class=\"chat__notifications\" style=\"display: block;\">\n        <p style=\"background-color: ${data.color}\">${data.body}</p>\n    </div>`\n    \n    messageBox.innerHTML += notificationMessage\n}\n\n// Update Connected Users\n// 1. We loop through the usernames array sent by the server when the event action is \"user joined\" or \"user left\"\n// 2. We create an empty string\n// 3. for each username in the array we append an li element\n// 4. outside the loop we set the innerHTML of the list container to that newly created string\n// 5. When a user leaves this function is fired (it's very fast so people won't noticed that we are not caching the array)\n// Not an ideal solution. Need to think of a better approach but I'm fasting so whatevs\n\n\nSocket.updateConnectedUsers = (usernames) => {\n    let  connectedUsers  = \"\"\n    usernamesContainer.innerHTML = \"\"\n    usernames.forEach( (username) => connectedUsers += `<li> ${username} </li>`)\n    usernamesContainer.innerHTML += connectedUsers\n}\n\n\n// Set Username\n// 1. We set the value of username (previously undefined) to the value of the username input\n// 2. If the username input is not empty (if the user has entered a username)\n//    We send an event to the server with an action of \"new user\" and a body equal to the newly created username\n//    We then hide the login page And show the chat page\n//    Finally we focus on the chat input for usability\n\nSocket.setUsername = () => {\n    // set the value of username to whatever the user has entered in the input field.trim()\n    Socket.username = usernameInput.value.trim()\n\n    if (Socket.username) {\n        Socket.connection.send(JSON.stringify({action: \"new user\", body: Socket.username}))\n        loginPage.style.display = \"none\"\n        chatPage.style.display = \"flex\"\n        document.body.className = \"no-svg\"\n        messageInput.focus()\n    }\n\n}\n\nexport {Socket}\n","const muteBtn = document.getElementById(\"mute\")\n\nlet Sounds = {\n    \n    track: new Audio(),\n    audioAllowed: true\n\n}\n\nSounds.track.src = '/public/audio/message.wav'\n\nSounds.playNotification = () => { if (Sounds.audioAllowed) { Sounds.track.play() } }\n\nSounds.toggleNotificationSounds = (event) => {\n    \n    const button = event.target\n\n    if (Sounds.audioAllowed){\n        Sounds.audioAllowed = false\n        button.innerHTML = \"Unmute Sound\"\n    } else {\n        Sounds.audioAllowed = true\n        button.innerHTML = \"Mute Sound\"\n    }\n} \n\nmuteBtn.addEventListener(\"click\", (event) => Sounds.toggleNotificationSounds(event), false)\n\nexport {Sounds}\n\n\n"]}