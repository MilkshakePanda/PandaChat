{"version":3,"sources":["node_modules/browser-pack/_prelude.js","assets/js/app.js"],"names":[],"mappings":"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","file":"app.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// Establish connection with the socket server\nconst connection = new WebSocket(\"ws://localhost:1337\", ['echo-protocol'])\n\nconst chatBox       = document.querySelector(\".chat__chat-box\")\nconst messageBox    = document.querySelector(\".chat__messages\")\nconst usernameInput = document.querySelector(\".login__username\")\nconst messageInput  = document.querySelector(\".chat__message-input\")\nconst usernamesContainer = document.querySelector(\".chat__users-list\")\n\nconst loginPage     = document.querySelector(\".login\")\nconst chatPage     = document.querySelector(\".chat\")\n\nconst audio = new Audio()\naudio.src = '/public/audio/message.wav'\n\nlet username\n\n// When the window loads\nwindow.onload = () => usernameInput.focus()\n\n// On open\nconnection.onopen = () => console.log(\"connected\") \n\n// On error\nconnection.onerror = (error) => console.log(\"There was an error of type \" + error + \" please try again shortly\")\n\n// On Message\nconnection.onmessage = (event) => {\n\n    const incomingData = JSON.parse(event.data)\n    const eventAction  = incomingData.action\n\n    // Here we check the action event sent by the server\n    // depending on the action, we perform different tasks\n    // Ex: if chat message then display message but if new user then notifyChatRoom and updateConnectedUsers\n    switch(eventAction) {\n\n        case \"new message\":\n            displayMessage(incomingData)\n            break;\n        case \"user joined\":\n            notifyUsers(incomingData)\n            console.log(incomingData.usernames)\n            updateConnectedUsers(incomingData.usernames)\n            break;\n        case \"user left\":\n            notifyUsers(incomingData)\n            updateConnectedUsers(incomingData.usernames)\n            break;\n    }\n\n}\n\n// Send Message\n// **This function is fired whenever the user hits enter and a username is set**\n// 1. We create a new JSON object with an event action of new message (which will be caught by the server to send back the content)\n// 2. We send it to the server\n// 3. We clear the input\n\n// **Note that on the server we are not explicitly checking for a \"new message\" event. We are listening for a \"new user\" event. If the event isn't that one then it's obviously a \"new message\" event (I'm currently fasting at the time of writing, this might not make sense at all brah)\n\nconst sendMessage = () => {\n    const message = JSON.stringify({\n        action: \"new message\",\n        body: messageInput.value\n\n    })\n    connection.send(message)\n    messageInput.value = \"\"\n}\n\n// Display Message\n// This function is called when the event sent by the server is \"new message\"\n// It takes the data sent by the server as a parameter\n// 1. we create a template string containing two span tags wrapped around a <p> tag\n// 2. we add the values from the data object to the elements\n// 3. we set the innerHTML of the chat container to that string\n\n\nconst displayMessage = (data) => {\n\n    let messageToDisplay  = `\n    \n    <div class=\"message\">\n        <span class=\"message__avatar\" style=\"background-color: ${data.color}\">${data.initials}</span>\n        <p class=\"message__body\">\n            <strong class=\"message__username\">${data.user}</strong>\n            ${data.body}\n        </p>\n        <time>${data.time}</time>\n    </div>\n    `\n\n    messageBox.innerHTML += messageToDisplay\n    playNotification()\n}\n\n\n// Notify Users\n// 1. We set the innerHTML of the notificationContainer to the message sent by the server (\"user connected, \"user left the chat\")\n// 2. We set the background color of the container to the one specified in the data object sent by the server\n// 3. We show it (it's display none by default\")\n// 4. After two seconds we hide it again\n\n// Create the element on the fly using template strings (className: chat__notifications)\nconst notifyUsers = (data) => {\n\n    const notificationMessage = `<div class=\"chat__notifications\" style=\"display: block;\">\n        <p style=\"background-color: ${data.color}\">${data.body}</p>\n    </div>`\n\n    setTimeout( () => notificationMessage.style.display = \"none\", 2000)\n}\n\n// Update Connected Users\n// 1. We loop through the usernames array sent by the server when the event action is \"user joined\" or \"user left\"\n// 2. We create an empty string\n// 3. for each username in the array we append an li element\n// 4. outside the loop we set the innerHTML of the list container to that newly created string\n// 5. When a user leaves this function is fired (it's very fast so people won't noticed that we are not caching the array)\n// Not an ideal solution. Need to think of a better approach but I'm fasting so whatevs\n\n\nconst updateConnectedUsers = (usernames) => {\n    let  connectedUsers  = \"\"\n    usernamesContainer.innerHTML = \"\"\n    usernames.forEach( (username) => connectedUsers += `<li> ${username} </li>`)\n    usernamesContainer.innerHTML += connectedUsers\n}\n\n\n// Set Username\n// 1. We set the value of username (previously undefined) to the value of the username input\n// 2. If the username input is not empty (if the user has entered a username)\n//    We send an event to the server with an action of \"new user\" and a body equal to the newly created username\n//    We then hide the login page And show the chat page\n//    Finally we focus on the chat input for usability\n\nconst setUsername = () => {\n    // set the value of username to whatever the user has entered in the input field.trim()\n    username = usernameInput.value.trim()\n    console.log(username)\n\n    if (username) {\n        connection.send(JSON.stringify({action: \"new user\", body: username}))\n        loginPage.style.display = \"none\"\n        chatPage.style.display = \"flex\"\n        document.body.className = \"no-svg\"\n        messageInput.focus()\n\n    }\n\n}\n\nconst playNotification = () => audio.play()\n\n\n// We listen for keydown events\n// When the user hits enter\n// If when they hit enter, the value of username is defined, then that means the user is trying to send a message (because they can see the chat page)\n    // So in that case we call the sendMessage function\n// However is username is not defined then they are still looking at the login page which means they want to set their username\n    // in that case we call the setUsername() function\n\nwindow.onkeydown = (event) => {\n\n    if (event.which === 13) {\n        event.preventDefault()\n\n        if (username) {\n            sendMessage()\n        }\n        else {\n            setUsername()\n        }\n\n    }\n}\n"]}